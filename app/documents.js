'use strict';

import faker from 'faker';
import Chance from 'chance';
const chance = new Chance();
import output from './output';

const documents = {}; // global variable to keep track of the generated documents
let documents_counter = 0; // global variable hold the total number of documents generated
let globals = {}; // a global variable to allow saving of values generated by models

// executes the building of a model
const run = async (current_model) => {
  // console.log('documents.run');
  // define a key based on the model path to hold the generated documents for the model
  documents[current_model.name] = [];
  // if there is a pre_run function call it
  if (current_model.data && current_model.data.pre_run) {
    current_model.data.pre_run(documents, globals, faker, chance);
  }
  let builds = [];
  let number = current_model.data.fixed || Math.floor(Math.random() * current_model.data.max) + current_model.data.min;
  console.log(`Generating ${number} documents for ${current_model.name} model`);
  for (let i = 0; i < number; i++) { // loop over each model and execute in order of dependency
    builds.push(build(current_model));
  }
  return await Promise
                .all(builds)
                .then(() => {
                  if (current_model.data.post_run) {
                    current_model.data.post_run(documents, globals, faker, chance);
                  }
                })
                .catch((e) => {
                  throw e;
                });
};

const build = async (current_model) => {
  try {
    documents_counter += 1;
    // generate the initial values
    let generated_document = await initialize_document(current_model);
    // if there is a pre_build function call it
    if (current_model.data && current_model.data.pre_build) {
      current_model.data.pre_build(generated_document, documents, globals, faker, chance);
    }
    generated_document = await build_properties(current_model, generated_document);
    generated_document = await build_process(current_model, generated_document);
    documents[current_model.name].push(generated_document);
    await output.flush(current_model, generated_document);
    // if there is a post_build function call it
    if (current_model.data && current_model.data.pre_build) {
      current_model.data.post_build(generated_document, documents, globals, faker, chance);
    }
  } catch (e) {
    throw e;
  }
};

const initialize_document = async (current_model) => {
  // console.log('initialize_document');
  let doc = {};
  let key;
  try {
    // generate the initial values
    for (key in current_model.properties) {
      if (current_model.properties.hasOwnProperty(key)) {
        doc[key] = initialize_value(current_model.properties[key].type);
        // if there is a pre build function execute it
        if (current_model.properties[key].data.pre_build) {
          doc[key] = current_model.properties[key].data.pre_build(doc[key], null, documents, globals, faker, chance);
        }
      }
    }
    return doc;
  } catch (e) {
    throw new Error(`Error: Initializing Properties in Model: "${current_model.name}" for Key: "${key}", Reason: ${e.message}`);
  }
};

const initialize_value = (data_type) => {
  // console.log('build_properties');
  let value;
  if (data_type === 'string') {
    value = '';
  } else if (data_type === 'object') {
    value = {};
  } else if ('number,integer,double,long,float'.indexOf(data_type) !== -1) {
    value = 0;
  } else if (data_type === 'array') {
    value = [];
  } else {
    value = null;
  }
  return value;
};

const build_properties = async (current_model, generated_document) => {
  // console.log('build_properties');
  let key;
  try {
    // generate the initial values
    for (key in current_model.properties) {
      // if there is a data block, attempt to generate the data for the property
      if (current_model.properties.hasOwnProperty(key) && current_model.properties[key].data) {
        if (current_model.properties[key].data.fake) { // if we are generating fake doc
          generated_document[key] = faker.fake(current_model.properties[key].data.fake);
        } else if (current_model.properties[key].data.value) { // if there is a static value
          generated_document[key] = current_model.properties[key].data.value;
        } else if (current_model.properties[key].data.build) { // if there is a build function
          // 'current_value', 'current_document', 'documents', 'globals', 'faker', 'chance',
          generated_document[key] = current_model.properties[key].data.build(
            generated_document[key], generated_document, documents, globals, faker, chance
          );
        }
      }
    }
    return generated_document;
  } catch (e) {
    throw new Error(`Error: Building Properties in Model: "${current_model.name}" for Key: "${key}", Reason: ${e.message}`);
  }
};

const build_process = async (current_model, generated_document) => {
  // console.log('build_process');
  let key;
  try {
    // loop over the generated results
    for (key in generated_document) {
      // if there is a post_build block
      if (current_model.properties[key].data && current_model.properties[key].data.post_build) {
        generated_document[key] = current_model.properties[key].data.post_build(
          generated_document[key], generated_document, documents, globals, faker, chance
        );
      }
      // if it is a number make sure it is treated as such
      if ('number,integer,long'.indexOf(current_model.properties[key].type) !== -1) {
        generated_document[key] = parseInt(generated_document[key]);
      }
      // if it is a number make sure it is treated as such
      if ('double,float'.indexOf(current_model.properties[key].type) !== -1) {
        generated_document[key] = parseFloat(generated_document[key]);
      }
    }
    return generated_document;
  } catch (e) {
    throw new Error(`Error: Transforming Properties in Model: "${current_model.name}" for Key: "${key}", Reason: ${e.message}`);
  }
};

const get_stats = () => {
  return documents_counter;
};

export default { run, get_stats };
